from logger import *               # logging output
import requests
from custom_auth import * # Read in all hardcoded authentication

class ExploitStrategy:
  """
  Implements a 'pseudo' Strategy Pattern for exploits. A concrete startegy is 
  passed into the constructor, whose execute method will overwrite this object 
  execute. All methods & assets within this class is accessible by the concrete
  strategy, it is passed to it. 

  Justification: exploits are very similar and only differ in their behvior. 
  Using the strategy pattern, we can configure just one class with one of many 
  behaviors. All common behavior and assets are captured in one place to be 
  reused by all concrete strategies. 

  Below is an example usage:

  sanitization = Exploit(pages, session, ConcreteStrategy))
  sanitization.execute() <- this calls the concrete strategy's execute method. 

  @tofferrosen
  """

  def __init__(self, pages, session, concrete_exploit, options):
    """
    constructor of ExpointStrategy

    @pages - an array of objects representing pages to be fuzzed.
    @session - the current requests session object
    @concrete_exploit - the concrete exploit object that implements 
    the method execute()
    @options - contains all options, particulary delay/slow, location of vectors,
    and whether the random option should be implemented or not.
    """
    self.concrete_exploit = concrete_exploit 
    self.pages = pages
    self.session = session
    self.options = options

  def execute(self):
    """
    execute strategy.
    calls execute of the concrete strategy passed into this object's constructor
    """
    self.concrete_exploit.execute(self.pages,self.session,self)

  def _getVectors(self):
    """
    returns an array representation of all vectors 
    @private - should only be used internally by concrete strategies
    """
    vectors = None

    try:
      vectors = open(self.options.vectors, "r").read().splitlines()
    except IOError, (ErrorNumber, ErrorMessage):

      if ErrorNumber == 2: # File not found
        logger.error("Oh noes! Vector file not found!")
      else:
        logger.error("You managed successfully to trip a #%d error" % ErrorNumber)
        logger.error(ErrorMessage)

    return vectors

  def _refreshDVWASession(self, url):
    """
    refreshes dvwa session/ new login
    """
    username = custom_auth["dvwa"]["username"]
    password = custom_auth["dvwa"]["password"]

    # Details to be posted to the login form
    payload = {
      "username": username,
      "password": password,
      "Login": "Login"
    }

    self.session = requests.Session()
    self.session.post(custom_auth["dvwa"]["login_url"], data=payload)
    page = self.session.get(url + "/" + "dvwa")

    # set the security cookie to low!
    cookies = self.session.cookies
    session_id = cookies["PHPSESSID"]
    self.session.cookies.clear() # clear the cookies in the cookie

    self.session.cookies["PHPSESSID"] = session_id # refreshed sesison id
    self.session.cookies["security"] = "low"

  def _validateSession(self, url):
    """ 
    validate that current session is still validate
    """

    page = self.session.get(url)

    # check if we are dvwa, if we have been redirected to login page
    if "http://127.0.0.1/dvwa/login.php" in page.url and "logout.php" not in url:
      logger.info("redirected to login, reauthenticating to dvwa")
      self._refreshDVWASession(page.url)


  def _executeVector(self, url, vector, form):
    """
    executes a vector for a given form and page and returns the response
    @url - the url 
    @vector - the vector to execute
    @form - the form to execute/fuzz the vector with.

    @private - should only be used internally by a concrete strategy
    """
    payload = {} # inputs to submit
    action = form.get('action')
    method = form.get('method')
    response = None 

    # validate that the session hasn't expired 
    # largest culpurit is if we have tried the logout page previously.
    self._validateSession(url)
    
    # fuzz all inputs in the form
    for input in form.get("inputs"):
      payload[input] = vector
    
    # supported actions are post/get
    try:
      if method == "post" or method == "POST":
          response = self.session.post(url + "/" + action, data = payload)

      elif method == "get" or method == "GET": 
          response = self.session.get(url + "/" + action, params = payload)

    except requests.exceptions.TooManyRedirects:
      logger.error("too many redirect exception trying " + action + " on " + url)

    return response
