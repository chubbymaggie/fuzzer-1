from logger import * # logging output

class SanitizationExploit():
	"""
	implements the concrete sanitization exploit
	strategy.

	possible exploits are: sql injection, xss exploit, and not sanitizing 
	special characters

	@toffer
	"""

	def execute(self, pages, session, strategy):
		"""
		execute strategy - fuzz all inputs and make sure 
		they have been sanitized
		"""
		vectors = strategy._getVectors()

		logger.info("Checking that input has been sanitized...")

		for page in pages:
			forms = page.get("inputs").get("forms")
			url = page.get("url")
			
			for form in forms:
				for vector in vectors:
					response = strategy._executeVector(url, vector, form)

					if response != None:
						self._checkForSanitization(vector, response, url)

		logger.info("Sanitization checks complete")


	def _checkForSQLExploit(self, response, url):
		"""
		checks if the response has a sql exploit 
		"""
		
		if "MySQL " in response.text:
			logger.info("SQL exploit found on page: " + url)

	def _checkForXSSExploit(self, response, url):
		"""
		checks if the response was successfully attacked by our XSS vector that adds
		a XSS cookie to the page
		"""
		cookies = response.cookies

		for cookie in cookies:
			if cookie.name == "xss" or cookie.value == "haha":
				logger.info("XSS exploit found on page: " + url)

	def _checkForSpecialChars(self, vector, response, url):
		"""
		checks to see that a few of the common special characters if in the vector has been 
		sanitized in 'da' response
		"""

		if "<" in vector or ">" in vector or "/" in vector or "\"" in vector or "?" in vector:
			if vector in response.text:
				logger.info("Special characters were not sanitized or escaped in page " + url)


	def _checkForSanitization(self, vector, response, url):
		""" 
		checks that response has been sanitized. 
		"""
		self._checkForSQLExploit(response, url)
		self._checkForXSSExploit(response, url)
		self._checkForSpecialChars(vector, response, url)

	

		
		


		

