from logger import *               # logging output
import requests

class ExploitStrategy:
  """
  Implements a 'pseudo' Strategy Pattern for exploits. A concrete startegy is 
  passed into the constructor, whose execute method will overwrite this object 
  execute. All methods & assets within this class is accessible by the concrete
  strategy, it is passed to it. 

  Justification: exploits are very similar and only differ in their behvior. 
  Using the strategy pattern, we can configure just one class with one of many 
  behaviors. All common behavior and assets are captured in one place to be 
  reused by all concrete strategies. 

  Below is an example usage:

  sanitization = Exploit(pages, session, ConcreteStrategy))
  sanitization.execute() <- this calls the concrete strategy's execute method. 

  @tofferrosen
  """

  def __init__(self, pages, session, concrete_exploit, options):
    """
    constructor of ExpointStrategy

    @pages - an array of objects representing pages to be fuzzed.
    @session - the current requests session object
    @concrete_exploit - the concrete exploit object that implements 
    the method execute()
    @options - contains all options, particulary delay/slow, location of vectors,
    and whether the random option should be implemented or not.
    """
    self.concrete_exploit = concrete_exploit 
    self.pages = pages
    self.session = session
    self.options = options

  def execute(self):
    """
    execute strategy.
    calls execute of the concrete strategy passed into this object's constructor
    """
    self.concrete_exploit.execute(self.pages,self.session,self)

  def _getVectors(self):
    """
    returns an array representation of all vectors 
    @private - should only be used internally by concrete strategies
    """
    vectors = None

    try:
      vectors = open(self.options.vectors, "r").read().splitlines()
    except IOError, (ErrorNumber, ErrorMessage):

      if ErrorNumber == 2: # File not found
        logger.error("Oh noes! Vector file not found!")
      else:
        logger.error("You managed successfully to trip a #%d error" % ErrorNumber)
        logger.error(ErrorMessage)

    return vectors

  def _executeVector(self, url, vector, form):
    """
    executes a vector for a given form and page and returns the response
    @url - the url 
    @vector - the vector to execute
    @form - the form to execute/fuzz the vector with.

    @private - should only be used internally by a concrete strategy
    """
    payload = {} # inputs to submit
    action = form.get('action')
    method = form.get('method')
    response = None 

    print(url)
    print(action)
    print(method)
    
    # fuzz all inputs in the form
    for input in form.get("inputs"):
      print(input)
      payload[input] = vector
    
    # supported actions are post/get
    try:
      if method == "post":
          response = requests.post(url + "/" + action, data = payload)

      elif method == "get":
          response = requests.get(url + "/" + action, params = payload)

    except requests.exceptions.TooManyRedirects:
      # do nothing - if we are logged in already and fill in
      # the form login.php we will end up in a redirect loop.
      pass

    return response
